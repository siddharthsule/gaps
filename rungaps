#!/usr/bin/env python3

# ------------------------------------------------------------------------------

"""
GAPS - Run Script
-----------------
This script is used to compile and run the GPU and CPU Shower codes. It
provides a number of options to control the number of events, the number of
cores to use, and the type of run to perform. The run types are:
    - gpu: Run the GPU simulation
    - cpu: Run the CPU Shower simulation
    - compare: Run both the GPU and CPU Shower and compare the results
    - full: Run both the GPU and CPU Shower for a range of event numbers
"""

# ------------------------------------------------------------------------------
# Modules

import argparse
import os

# ------------------------------------------------------------------------------
# Functions

from gaps.interface.logo import print_logo
from gaps.interface.compile import compile_code
from gaps.interface.lhapdf_gpu import check_lhapdf_path
from gaps.interface.run import run, run_cpu_cluster


# ------------------------------------------------------------------------------
# Emission Tracking with CodeCarbon

codecarbon_available = False
try:
    from codecarbon import OfflineEmissionsTracker
    codecarbon_available = True
except ImportError:
    codecarbon_available = False


# ------------------------------------------------------------------------------
# Parse the Arguments

def parse_arguments():
    # Set up argument parser
    p = argparse.ArgumentParser(description='Run GPU or CPU Shower')

    # Run type
    p.add_argument('-r', '--runtype',
                   type=str,
                   default='gpu',
                   choices=['gpu', 'cpu', 'compare', 'cpu-cluster', 'tune'],
                   help='choose run type (default: gpu)')

    # Process and Parameters
    p.add_argument('-p', '--process',
                   type=str,
                   choices=['LEP', 'LHC'],
                   default='LEP',
                   help='set the process (default: LEP)')

    p.add_argument('-nlo', '--nlo',
                   action='store_true',
                   help='enable NLO corrections (default: False)')

    p.add_argument('-e', '--root_s',
                   type=float,
                   help='set the Centre of Mass Energy, sqrt(s)')

    # Strong Coupling
    p.add_argument('-asmz', '--asmz',
                   type=float,
                   default=0.118,
                   help='set the strong coupling asmz (default: 0.118)')

    p.add_argument('-fixas', '--fixas',
                   action='store_true',
                   help='fix the strong coupling to asmz (default: False)')

    p.add_argument('-noshower', '--noshower',
                   action='store_true',
                   help='skip the shower section (default: False)')

    # Shower Parameters
    p.add_argument('-t_c', '--t_c',
                   type=float,
                   default=1.0,
                   help='set the shower cutoff in GeV (default: 1.0 GeV)')

    p.add_argument('-n_em_max', '--n_emissions_max',
                   type=int,
                   default=1000,
                   help='set the maximum number of emissions, including the MC@NLO Emission (default: 1000)')

    # Run options
    p.add_argument('-n', '--nevents',
                   type=int,
                   default=10000,
                   help='set the number of events (default: 10000)')

    p.add_argument('-ncpu', '--ncpu',
                   type=int,
                   default=8,
                   help='number of cpus for cpu-cluster run')

    # GPU and GPU Tuning
    p.add_argument('-do_partitioning', '--do_partitioning',
                   type=str,
                   choices=['yes', 'no'],
                   default='yes',
                   help='enable event record partitioning (default: yes)')

    p.add_argument('-t', '--threads',
                   type=int,
                   default=256,
                   help='set the number of threads per block (default: 256)')

    # Profiling
    p.add_argument('-nsys', '--nsysprofile',
                   action='store_true',
                   help='enable nsys profiling')

    p.add_argument('-codecarbon', '--codecarbon',
                   action='store_true',
                   help='enable codecarbon emissions tracking')

    p.add_argument('-gprof', '--gprof',
                   action='store_true',
                   help='Enable gprof profiling for CPU Shower')

    # Parse the arguments
    args = p.parse_args()
    return args

# ------------------------------------------------------------------------------
# Adjust the root_s value based on the process - if not provided


def adjust_root_s(args):
    # Adjust root_s if not provided
    if args.root_s is None:
        if args.process == 'LEP':
            args.root_s = 91.2
        elif args.process == 'LHC':
            args.root_s = 13000.0

# ------------------------------------------------------------------------------
# Compile and Run the Code


def compile_and_run(args):

    # --------------------------------------------------------------------------
    # Compile the code

    if args.runtype in ['gpu', 'compare', 'tune']:
        compile_code('gpu', args)

    if args.runtype in ['cpu', 'compare', 'cpu-cluster']:
        compile_code('cpu', args)

    # --------------------------------------------------------------------------
    # Run the code

    if args.runtype in ['gpu', 'compare']:
        if (codecarbon_available and args.codecarbon):
            tracker = OfflineEmissionsTracker(
                country_iso_code="GBR",
                output_file="gpu-emissions.dat",
                measure_power_secs=5,
                tracking_mode="process")
            tracker.start()
            run('gpu', args)
            tracker.stop()
        else:
            run('gpu', args)

    if args.runtype in ['cpu', 'compare']:
        if (codecarbon_available and args.codecarbon):
            tracker = OfflineEmissionsTracker(
                country_iso_code="GBR",
                output_file="cpu-emissions.dat",
                measure_power_secs=5,
                tracking_mode="process",
                # Used to avoid tracking gpus (unless there is a 1000th gpu!)
                gpu_ids="1000")
            tracker.start()
            run('cpu', args)
            tracker.stop()
        else:
            run('cpu', args)

    if args.runtype == 'cpu-cluster':
        if (codecarbon_available and args.codecarbon):
            # Ensure CodeCarbon works fine with more than 64 threads
            os.environ["OMP_NUM_THREADS"] = "100"
            os.environ["MKL_NUM_THREADS"] = "100"
            os.environ["NUMEXPR_MAX_THREADS"] = "100"
            tracker = OfflineEmissionsTracker(
                country_iso_code="GBR",
                output_file="cpu-cluster-emissions.dat",
                measure_power_secs=5,
                tracking_mode="process",
                # Used to avoid tracking gpus (unless there is a 1000th gpu!)
                gpu_ids="1000")
            tracker.start()
            run_cpu_cluster(args.ncpu, args)
            tracker.stop()
        else:
            run_cpu_cluster(args.ncpu, args)

    # --------------------------------------------------------------------------
    # Kernel Tuning

    if args.runtype == 'tune':

        # Remove previous results and make folder
        if os.path.exists('gpu-time.dat'):
            os.remove('gpu-time.dat')

        # Possible number of threads per block
        # blocks per grid = (n_events + threads - 1) / threads
        threads = [32, 64, 128, 256, 512]

        n_list = [10000, 100000, 1000000]

        # Run the GPU simulation for different number of threads
        # Do this 10 times for each number of threads
        # And for each number of events
        for n in n_list:
            args.nevents = n
            for t in threads:
                args.threads = t
                for i in range(10):
                    print(f"Running GPU Shower with {t} threads: " +
                          str(i+1) + " of 10")
                    run('gpu', args)


# ------------------------------------------------------------------------------
# Main Function


def main():

    # Get the arguments
    args = parse_arguments()
    adjust_root_s(args)

    # Print the GAPS logo
    print_logo(args)

    # Verify Setup
    check_lhapdf_path()

    # Compile and run the code
    compile_and_run(args)


if __name__ == "__main__":
    main()
